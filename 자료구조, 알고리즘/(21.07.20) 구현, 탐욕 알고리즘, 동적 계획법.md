# 구현(Implementation), 탐욕 알고리즘(Greedy Algorithm), 동적 계획법(Dynamic Programming) 

***

## 구현 (Implementation)
- 구현 : 머리속에 있는 알고리즘을 소스코드로 바꾸는 과정

- 구현 목표 : 본인이 선택한 프로그래밍 언어의 문법을 정확히 알고 있어야 하며, 문제의 조건에 전부 부합하는 코드를 실수 없이 빠르게 작성하는 것

- 구현 능력을 보는 대표적인 사례 : 완전 탐색(brute force)과 시뮬레이션(simulation)

### 1. 완전 탐색
- 완전 탐색 : 단순히 모든 경우의 수를 탐색하는 모든 경우를 통칭

- 완전 탐색 방법 : brute Force(조건/반복을 사용하여 해결 - 무차별 대입), 재귀, 순열, DFS/BFS 등

- 완전 탐색은 효율적이지 않은 경우가 있음

### 2. 시뮬레이션(simulation)
- 시뮬레이션은 모든 과정과 조건이 제시되어, 그 과정을 거친 결과가 무엇인지 확인하는 유형

- 보통 문제에서 설명해 준 로직 그대로 코드로 작성하면 되지만 길고 자세하여 코드로 옮기는 작업이 까다로울 수 있음

- 문제에 대한 이해를 바탕으로 제시하는 조건을 하나도 빠짐없이 처리해야 하며, 하나라도 놓친다면 통과할 수 없음

***

## 탐욕 알고리즘 (Greedy Algorithm)
- 선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적 해답에 도달하는 방법

- 상 최적의 결과를 도출하는 것은 아니지만, 어느 정도 최적에 근사한 값을 빠르게 도출할 수 있는 장점이 있어 근사 알고리즘으로 사용

### 1. 탐욕 알고리즘의 문제 해결 방법
- 선택 절차(Selection Procedure): 현재 상태에서의 최적의 해답을 선택

- 적절성 검사(Feasibility Check): 선택된 해가 문제의 조건을 만족하는지 검사

- 해답 검사(Solution Check): 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택 절차로 돌아가 위의 과정을 반복

### 2. 탐욕 알고리즘을 적용하기 위한 전제조건
- 탐욕적 선택 속성(Greedy Choice Property) : 앞의 선택이 이후의 선택에 영향을 주지 않음

- 최적 부분 구조(Optimal Substructure) : 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성

***

## 동적 계획법 (Dynamic Programming)
- 탐욕 알고르즘처럼 작은 문제에서 시작하지만, 동적 계획법은 순간 최적의 선택이 아닌 모든 경우의 수를 조합해서 최적의 해법 찾기

- 원리 : 주어진 문제를 여러 개의 하위 문제로 나누어 풀고, 하위 문제들의 해결 방법을 결합하여 최종 문제를 해결

- 하위 문제를 계산한 뒤 그 해결책을 저장하고, 나중에 동일한 하위 문제를 만날 경우 저장된 해결책을 적용해 계산 횟수를 줄임

- 동적 프로그래밍은 아래 두 가지 조건이 만족해야 사용 가능

### 조건1. 큰 문제를 작은 문제로 나눌 수 있고, 이 작은 문제가 중복해서 발견됨 (Overlapping Sub-problems)
- 큰 문제로부터 나누어진 작은 문제는 큰 문제를 해결할 때 여러 번 반복해서 사용될 수 있어야 힘

- 작은 문제의 결과를 큰 문제를 해결하기 위해 여러 번 반복하여 사용할 수 있을 때, 부분 문제의 반복(Overlapping Sub-problems)이라는 조건을 만족

- 예시 : 피보나치 수열

### 조건2. 작은 문제에서 구한 정답을 큰 문제에서도 사용할 수 있다. (Optimal Substructure)
-  작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하며, 정답은 최적의 해결 방법(Optimal solution)을 의미함

- 주어진 문제의 작은 문제들의 최적의 해법(Optimal solution of Sub-problems)을 찾아야 함

- 그리고 작은 문제들의 최적의 해법을 결합하면, 결국 전체 문제의 최적의 해법(Optimal solution)을 구할 수 있음

- 예시 : 최단 경로 구하기

### 용례 : Recursion(재귀) + Memoization
- Memoization : 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술

- 다이내믹 프로그래밍은 하위 문제의 해결책을 저장한 뒤 동일한 하위 문제가 나왔을 경우 저장해 놓은 해결책을 이용하는데, 이때 결과를 저장하는 방법이 Memoization

- 재귀 함수를 이용한 다이내믹 프로그래밍 : 큰 문제부터 시작하여 작은 문제를 해결해 나가기 (Top-Down)

### 용례 : Iteration(반복) + Tabulation(표)
- 반복문을 이용한 다이내믹 프로그래밍 : 작은 문제에서부터 시작하여 큰 문제를 해결해 나가는 방법 (Buttom-up)
